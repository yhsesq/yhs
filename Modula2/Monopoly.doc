101CS Coursework

Monopoly Game Simulation
------------------------


The program was a simulation of the monopoly game with the user required
to control the speed of play. The game was based on an object oriented 
approach, which improved the clarity and reliability of the program,
but, increased the complexity of the programming required.
Hence, the problem had to be broken down and the individual objects
tested individually, before implementing them in the main program.

Design
------

The structure of the program and it's individual objects had already
been mapped out on the instruction sheet. Hence, there was no need
to design the individual objects. However, the interface and data
file were left to the programmer. In order to simplify the program,
the interface was kept at the bare minimum required. Hence, the chances 
of a user input crashing the program were kept to a minimum.
Since the program was text based, a graphical board design could not
be created. Hence, a text based representation of the board was used
with a simple, two button interface for the user. The user input
and output routines were created and tested. In this program,
the user simply inputs the name of the data file (default extension
was taken as dat) and type r<ENTER> to roll the die and play the game
or q to quit. Every time the user rolls the die, the die is first rolled
randomly for player 1, the result shown on screen, his square is calculated,
the board updated and the same process repeated for player 2. The program 
then dumps a text based representation of the board on the screen with the 
updated moves calculated and displayed on the board. The exact postion
of the players and the amount of money left is also displayed. Since an
object oriented approach was required, a seperate procedure was created 
for the play loops and the main program was kep to the bare minimum 
required. The array of 100 characters used for user input is merely to
prevent the user from crashing the program by accidently typing rrr<ENTER>
or anything similar. 

Object Design
-------------

Once the main program had been written, the objects were based on the 
approach recommended on the instruction sheet. The module dependancy diagram
is as shown below :-

Module                          Dependant Modules

Die ----------------------------> Random, InOut

Square -------------------------> Player

Board --------------------------> InOut, Player, Square

Player -------------------------> InOut

Game ---------------------------> InOut, Player, Board, Die

As is shown in the diagram, all the modules depend on each other
to some degree or the other. Hence, it was necessary to start the 
design from the modules which required the LEAST interaction with the 
others. In this case, it was the module Die. Since the entire module is
virtually given in the instruction sheet, it was typed out and tested.
An extra element , Die(zero) was added in case the module failed to respond.
An extra error check was also added in the case statement to prevent
the module from ignoring a potential error, incase one existed. However, 
no errors were found. The next module to be created was Player, since it 
was called by virtually all the modules. Since player consisted of a 
definition and a small routine to print the status of both players, this 
was easily created and tested. Square was then created, which consisted 
of an object definition for the squares on the board. Board then defined the
board and used both the modules. This was tested by creating a simple 
program based on the old Monopoly excercise (11b), which merely read and 
printed out the squares using variant records. The final module which
was ceated was Game, which played exactly one roll of the die for one 
player and handled all the calculations. This was tested by integrating it
into the main program, along with all the other modules. The entire program
was then tested several times in order to determine the accuaracy of the 
calculations. Since the manual calculations for the game tallied with
the results generated by the game, the program was presumed to be
valid and accurate. A print out of a sample game was then obtained and
is included.  
